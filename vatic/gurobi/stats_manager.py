"""Collecting and reporting statistics on the states of the simulation."""

from __future__ import annotations

import os
from pathlib import Path
import bz2
import dill as pickle
from typing import Optional

import numpy as np
import pandas as pd

from ..egret.time_manager import VaticTime
from .formulations import RucModel, ScedModel


class StatsManager:
    """Processing statistics generated by solved simulation models.

    This class consolidates data produced by the unit commitment and economic
    dispatch models solved as part of a simulation run and produces reports
    in the form of data tables saved to file as well as plots.

    See prescient.simulator.reporting_manager
    and prescient.simulator.stats_manager for the original implementations of
    the functionalities included in this class.
    """

    def __init__(self,
                 write_dir: Path | str | None,
                 output_detail: int, verbosity: int, output_max_decimals: int,
                 create_plots: bool, save_to_csv: bool,
                 last_conditions_file: str | Path) -> None:
        self._sced_stats = dict()
        self._ruc_stats = dict()

        self.write_dir = write_dir
        self.output_detail = output_detail
        self.verbosity = verbosity
        self.max_decimals = output_max_decimals
        self.create_plots = create_plots
        self.save_to_csv = save_to_csv

        if last_conditions_file:
            self.last_conditions_file = Path(last_conditions_file)
        else:
            self.last_conditions_file = None

        if self.write_dir is None and create_plots:
            raise ValueError("Cannot create plots without providing an "
                             "output directory for saving them!")

        if self.write_dir is not None:
            os.makedirs(self.write_dir, exist_ok=True)

            if self.create_plots:
                os.makedirs(Path(self.write_dir, "plots"), exist_ok=True)

    def _dict_to_frame(self, stats: dict[tuple[str, int], int | float]):
        return pd.Series(stats).unstack().round(self.max_decimals)

    def collect_ruc_solution(self,
                             time_step: VaticTime,
                             ruc: RucModel) -> None:
        """Gets the key statistics from a solved reliability unit commitment.

        Args
        ----
            time_step   The time in the simulation at which the RUC was solved.
            ruc         The solved RUC model.
        """

        self._ruc_stats[time_step] = {
            'runtime': ruc.solve_time,

            'fixed_cost': round(sum(ruc.results['commitment_cost'].values()),
                                self.max_decimals),
            'variable_cost': round(sum(
                ruc.results['production_cost'].values()), self.max_decimals),

            'generation': self._dict_to_frame(ruc.results['power_generated']),
            'commitments': self._dict_to_frame(ruc.results['commitment']),
            'reserves': self._dict_to_frame(ruc.results['reserves_provided']),
            }

        if self.verbosity > 0:
            print("RUC fixed costs: "
                  f"{self._ruc_stats[time_step]['fixed_cost']}"
                  "\tvariable costs: "
                  f"{self._ruc_stats[time_step]['variable_cost']}"
                  "\n")

    def collect_sced_solution(self,
                              time_step: VaticTime, sced: ScedModel,
                              lmp_sced: Optional[ScedModel] = None) -> None:
        """Gets the key statistics from a solved economic dispatch.

        Args
        ----
            time_step   The time in the simulation at which the RUC was solved.
            sced        The solved security-constrained economic dispatch model.

            lmp_sced    If applicable, an additional economic dispatch that was
                        solved to get locational marginal prices.
        """

        self._sced_stats[time_step] = {
            'runtime': sced.solve_time,

            'total_demand': round(sced.Demand.iloc[:, 0].sum(),
                                  self.max_decimals),

            'fixed_cost': round(sum(cost for (g, t), cost
                                    in sced.results['commitment_cost'].items()
                                    if t == sced.InitialTime),
                                self.max_decimals),

            'variable_cost': round(
                sum(cost for (g, t), cost
                    in sced.results['production_cost'].items()
                    if t == sced.InitialTime),
                self.max_decimals
                ),

            'thermal_generation': round(
                sum(pwr for (g, t), pwr
                    in sced.results['power_generated'].items()
                    if g in sced.ThermalGenerators and t == sced.InitialTime),
                self.max_decimals
                ),

            'renewable_generation': round(
                sum(pwr for (g, t), pwr
                    in sced.results['power_generated'].items()
                    if g in sced.RenewableGenerators
                    and t == sced.InitialTime),
                self.max_decimals
                ),

            'load_shedding': round(
                sum(shed for (b, t), shed
                    in sced.results['load_shedding'].items()
                    if t == sced.InitialTime),
                self.max_decimals
                ),

            'over_generation': round(
                sum(pwr for (b, t), pwr
                    in sced.results['over_generation'].items()
                    if t == sced.InitialTime),
                self.max_decimals
                ),

            'reserve_shortfall': round(
                sum(shrt for t, shrt
                    in sced.results['reserve_shortfall'].items()
                    if t == sced.InitialTime),
                self.max_decimals
                ),

            }

        if lmp_sced:
            pass

        if self.verbosity > 0:
            print("SCED fixed costs: "
                  f"{self._sced_stats[time_step]['fixed_cost']}"
                  "\tvariable costs: "
                  f"{self._sced_stats[time_step]['variable_cost']}")

    def consolidate_output(self, sim_runtime=None) -> dict[str, pd.DataFrame]:
        """Creates tables storing outputs of all models this simulation ran."""

        report_dfs = {
            'hourly_summary': pd.DataFrame({
                time_step: {'FixedCosts': stats['fixed_cost'],
                            'VariableCosts': stats['variable_cost'],
                            'LoadShedding': stats['load_shedding']}
                for time_step, stats in self._sced_stats.items()
                }).T,
            }

        import pdb; pdb.set_trace()

        return report_dfs
