#  ___________________________________________________________________________
#
#  Prescient
#  Copyright 2020 National Technology & Engineering Solutions of Sandia, LLC
#  (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
#  Government retains certain rights in this software.
#  This software is distributed under the Revised BSD License.
#  ___________________________________________________________________________

import os
import csv
from pathlib import Path
import bz2
import dill as pickle
from typing import TypeVar, Callable, Iterable, Any, Union, Dict
import pandas as pd

from prescient.simulator.manager import _Manager
from prescient.simulator.reporting_manager import (
    _collect_time, _collect_time_assert_equal,
    _add_timeseries_attribute_to_egret_dict
    )

from prescient.simulator.stats_manager import StatsManager
from prescient.stats.overall_stats import OverallStats
from prescient.stats.daily_stats import DailyStats
from egret.data.model_data import ModelData
from egret.models.unit_commitment import _time_series_dict

# If appropriate back-ends for Matplotlib are not installed
# (e.g, gtk), then graphing will not be available.
try:
    from prescient.util import graphutils
    graphutils_functional = True
except ValueError:
    print("***Unable to load Gtk back-end for matplotlib - graphics generation is disabled")
    graphutils_functional = False


RecordType = TypeVar('RecordType')
KeyType = TypeVar('KeyType')
Dialect = Union[str, csv.Dialect]


class ListReporter:
    ''' Writes a row of data to a CSV file for each record object provided.

        An instance of this class writes data in CSV format to a provided
        file (or file-like object).  Each time write_record() is called,
        data is extracted from the supplied record object and a single row
        is written to the CSV file.  How data is extracted from the record
        is determined by callable objects passed as arguments when the
        CsvReporter is created.
    '''

    def __init__(self, header_to_value_map):
        ''' Constructor

            Parameters
            ----------
            fileobj
                A file or other object with a write() method that data will be written to
            headers
                Strings that will be the first line written to the CSV.  May be None if
                a header row is not wanted.
            row_data_provider
                A callable that takes a record as an argument and returns an array of
                values that will be written to the file as a row of CSV.
            dialect
                A dialect or dialect name, as described in documentation for csv.writer().
        '''
        self.data = list()
        self.headers = tuple(header_to_value_map.keys())

        self.map = lambda rec: tuple(func(rec)
                                     for func in header_to_value_map.values())

    def write_record(self, record: RecordType):
        ''' Write a row to the CSV, with data from the supplied record

            This method converts a record object to an array of values by calling the row_from_record
            iterable supplied to the constructor.  The resulting array is then written to the file.

            Parameters
            ----------
            record
                A data record that will be converted to a line of CSV and written to the file
        '''
        self.data += [self.map(record)]


class ListMultiRowReporter:
    ''' Writes multiple rows of data to a CSV file for each record object provided.

        An instance of this class writes data in CSV format to a provided
        file (or file-like object).  Each time write_record() is called,
        a set of row keys is generated for the record, and row of data is written
        to the CSV for each row key.  Row keys are generated by a Callable supplied
        to the constructor, and the row of data for each key is generated by a
        second Callable, also supplied to the constructor.
    '''

    def __init__(self,
                 key_provider: Callable[[RecordType], Iterable[KeyType]],
                 header_to_value_map: Dict[
                     str, Callable[[RecordType, KeyType], Any]],
                 write_headers=True) -> None:
        ''' Constructor

            Parameters
            ----------
            fileobj
                A file or other object with a write() method that data will be written to
            headers
                Strings that will be the first line written to the CSV.  May be None if
                a header row is not wanted.
            key_provider
                A callable that takes a record as an argument and returns an iterable of
                rowkeys.  One line of CSV data will be written to the file for each returned
                rowkey.
            row_data_provider
                A callable that takes a record and a row key as arguments and returns an
                array of values that will be written to the file as a row of CSV data
                for the record and the rowkey.
            dialect
                A dialect or dialect name, as described in documentation for csv.writer().
        '''
        self.data = list()
        self.headers = tuple(header_to_value_map.keys())
        self.write_headers = write_headers

        self._key_provider = key_provider
        self.map = lambda rec, key: tuple(
            func(rec, key) for func in header_to_value_map.values())

    def write_record(self, record: RecordType):
        ''' Write multiple rows of CSV data extracted from a single supplied record

            This method converts a record object to any number of rows of CSV and writes them to the file.
            The number of rows is determined by passing the record to the key_provider callable
            supplied to the constructor.  For each key returned by that method, the row_data_provider method
            is called, passing the original record and the row key as arguments.  The array returned from
            that call is then written to the file in CSV format.

            Parameters
            ----------
            record
                A data record that will be converted to multiple lines of CSV and written to the file
        '''
        self.data += [self.map(record, k) for k in self._key_provider(record)]


class ReportingManager(_Manager):

    def __init__(self, options, light_output, stats_manager: StatsManager):
        self.write_dir = options.output_directory

        if not options.disable_stackgraphs:
            os.makedirs(Path(self.write_dir, "plots"), exist_ok=True)

        self._round = lambda val : round(val,
                                         options.output_max_decimal_places)

        self.reports = dict()

        # set up runtimes
        self.reports['runtimes'] = ListReporter({
            'Date':       lambda ops: str(ops.timestamp.date()),
            'Hour':       lambda ops: ops.timestamp.hour,
            'Minute':     lambda ops: ops.timestamp.minute,
            'Type':       lambda ops: "SCED",
            'Solve Time': lambda ops: self._round(ops.sced_runtime)
            })

        stats_manager.register_for_sced_stats(
            self.reports['runtimes'].write_record)

        if options.sced_frequency_minutes != 60:
            self.reports['hr_runtime'] = ListReporter({
                'Date':       lambda hourly: str(hourly.date),
                'Hour':       lambda hourly: hourly.hour,
                'Minute':     lambda hourly: 0,
                'Type':       lambda hourly: "Hourly Average",
                'Solve Time': lambda hourly: self._round(
                    hourly.average_sced_runtime)
                })

            stats_manager.register_for_hourly_stats(
                self.reports['hr_runtimes'].write_record)

        # set up thermal detail
        if not light_output:
            self.reports['thermal_detail'] = ListMultiRowReporter(
                lambda stats: stats.observed_thermal_dispatch_levels.keys(), {
                    'Date': lambda ops, g: str(ops.timestamp.date()),
                    'Hour': lambda ops, g: ops.timestamp.hour,
                    'Minute': lambda ops, g: ops.timestamp.minute,
                    'Generator': lambda ops, g: g,
                    'Dispatch': lambda ops, g: self._round(
                        ops.observed_thermal_dispatch_levels[g]),
                    'Dispatch DA': lambda ops, g: (
                        self._round(ops.thermal_gen_cleared_DA[g])
                        if options.compute_market_settlements else None
                    ),
                    'Headroom': lambda ops, g: self._round(
                        ops.observed_thermal_headroom_levels[g]),
                    'Unit State': lambda ops, g: ops.observed_thermal_states[
                        g],
                    'Unit Cost': lambda ops, g: self._round(
                        ops.observed_costs[g]),
                    'Unit Market Revenue': lambda ops, g: (
                        self._round(ops.thermal_gen_revenue[g]
                                    + ops.thermal_reserve_revenue[g])
                        if options.compute_market_settlements else None
                    ),
                    'Unit Uplift Payment': lambda hourly, g: (
                        self._round(hourly.thermal_uplift[g])
                        if options.compute_market_settlements else None
                    )
                    }
                )

            stats_manager.register_for_sced_stats(
                self.reports['thermal_detail'].write_record)

            # set up renewables detail
            self.reports['renewables_detail'] = ListMultiRowReporter(
                lambda ops: ops.observed_renewables_levels.keys(), {
                    'Date': lambda ops, g: str(ops.timestamp.date()),
                    'Hour': lambda ops, g: ops.timestamp.hour,
                    'Minute': lambda ops, g: ops.timestamp.minute,
                    'Generator': lambda ops, g: g,
                    'Output': lambda ops, g: self._round(
                        ops.observed_renewables_levels[g]),
                    'Output DA': lambda ops, g: (
                        self._round(ops.renewable_gen_cleared_DA[g])
                        if options.compute_market_settlements else None
                    ),
                    'Curtailment': lambda ops, g: self._round(
                        ops.observed_renewables_curtailment[g]),
                    'Unit Market Revenue': lambda ops, g: (
                        self._round(ops.renewable_gen_revenue[g])
                        if options.compute_market_settlements else None
                    ),
                    'Unit Uplift Payment': lambda ops, g: (
                        self._round(ops.renewable_uplift[g])
                        if options.compute_market_settlements else None
                    )
                    }
                )


            stats_manager.register_for_sced_stats(
                self.reports['renewables_detail'].write_record)

            # set up bus detail
            self.reports['bus_detail'] = ListMultiRowReporter(
                lambda ops: ops.observed_bus_mismatches.keys(), {
                    'Date': lambda ops, b: str(ops.timestamp.date()),
                    'Hour': lambda ops, b: ops.timestamp.hour,
                    'Minute': lambda ops, b: ops.timestamp.minute,
                    'Bus': lambda ops, b: b,
                    'Demand': lambda ops, b: self._round(ops.bus_demands[b]),
                    'Shortfall': lambda ops, b: (
                        self._round(ops.observed_bus_mismatches[b])
                        if ops.observed_bus_mismatches[b] > 0.0 else 0.0
                        ),
                    'Overgeneration': lambda ops, b: (
                        self._round(-ops.observed_bus_mismatches[b])
                        if ops.observed_bus_mismatches[b] < 0.0 else 0.0
                        ),
                    'LMP': lambda ops, b: self._round(
                        ops.observed_bus_LMPs[b]),
                    'LMP DA': lambda ops, b: (
                        self._round(ops.planning_energy_prices[b])
                        if options.compute_market_settlements else None
                        )
                    }
                )

            stats_manager.register_for_sced_stats(
                self.reports['bus_detail'].write_record)

            # set up line detail
            self.reports['line_detail'] = ListMultiRowReporter(
                lambda ops: ops.observed_flow_levels.keys(), {
                    'Date': lambda ops, l: str(ops.timestamp.date()),
                    'Hour': lambda ops, l: ops.timestamp.hour,
                    'Minute': lambda ops, l: ops.timestamp.minute,
                    'Line': lambda ops, l: l,
                    'Flow': lambda ops, l: self._round(
                        ops.observed_flow_levels[l])
                    }
                )

            stats_manager.register_for_sced_stats(
                self.reports['line_detail'].write_record)

        # set up hourly generator summary
        self.reports['hourly_gen_summary'] = ListReporter({
            'Date': lambda hourly: str(hourly.date),
            'Hour': lambda hourly: hourly.hour,
            'Load shedding': lambda hourly: self._round(hourly.load_shedding),
            'Reserve shortfall': lambda hourly: self._round(
                hourly.reserve_shortfall),
            'Available reserves': lambda hourly: self._round(
                hourly.available_reserve),
            'Over generation': lambda hourly: self._round(
                hourly.over_generation),
            'Reserve Price DA': lambda hourly: (
                self._round(hourly.planning_reserve_price)
                if options.compute_market_settlements else None
                ),
            'Reserve Price RT': lambda hourly: self._round(
                hourly.reserve_RT_price)
            })

        stats_manager.register_for_hourly_stats(
            self.reports['hourly_gen_summary'].write_record)

        # set up hourly summary

        self.reports['hourly_summary'] = ListReporter({
            'Date': lambda hourly: str(hourly.date),
            'Hour': lambda hourly: hourly.hour,
            'TotalCosts': lambda hourly: self._round(hourly.total_costs),
            'FixedCosts': lambda hourly: self._round(hourly.fixed_costs),
            'VariableCosts': lambda hourly: self._round(hourly.variable_costs),
            'LoadShedding': lambda hourly: self._round(hourly.load_shedding),
            'OverGeneration': lambda hourly: self._round(
                hourly.over_generation),
            'ReserveShortfall': lambda hourly: self._round(
                hourly.reserve_shortfall),
            'RenewablesUsed': lambda hourly: self._round(
                hourly.renewables_used),
            'RenewablesCurtailment': lambda hourly: self._round(
                hourly.renewables_curtailment),
            'Demand': lambda hourly: self._round(hourly.total_demand),
            'Price': lambda hourly: self._round(hourly.price)
            })

        stats_manager.register_for_hourly_stats(
            self.reports['hourly_summary'].write_record)

        # set up daily summary
        daily_columns = {
            'Date': lambda daily: str(daily.date),
            'Demand': lambda daily: self._round(daily.this_date_demand),
            'Renewables available': lambda daily: self._round(
                daily.this_date_renewables_available),
            'Renewables used': lambda daily: self._round(
                daily.this_date_renewables_used),
            'Renewables penetration rate': lambda daily: self._round(
                daily.this_date_renewables_penetration_rate),

            # TODO: Implement
            'Average price': lambda daily: self._round(
                daily.this_date_average_price),
            'Fixed costs': lambda daily: self._round(
                daily.this_date_fixed_costs),
            'Generation costs': lambda daily: self._round(
                daily.this_date_variable_costs),
            'Load shedding': lambda daily: self._round(
                daily.this_date_load_shedding),
            'Over generation': lambda daily: self._round(
                daily.this_date_over_generation),
            'Reserve shortfall': lambda daily: self._round(
                daily.this_date_reserve_shortfall),
            'Renewables curtailment': lambda daily: self._round(
                daily.this_date_renewables_curtailment),
            'Number on/offs': lambda daily: daily.this_date_on_offs,
            'Sum on/off ramps': lambda daily: self._round(
                daily.this_date_sum_on_off_ramps),
            'Sum nominal ramps': lambda daily: self._round(
                daily.this_date_sum_nominal_ramps)}

        if options.compute_market_settlements:
            daily_columns.update({
                'Renewables energy payments': lambda daily: self._round(
                    daily.this_date_renewable_energy_payments),
                'Renewables uplift payments': lambda daily: self._round(
                    daily.this_date_renewable_uplift),
                'Thermal energy payments': lambda daily: self._round(
                    daily.this_date_thermal_energy_payments),
                'Thermal uplift payments': lambda daily: self._round(
                    daily.this_date_thermal_uplift),
                'Total energy payments': lambda daily: self._round(
                    daily.this_date_energy_payments),
                'Total uplift payments': lambda daily: self._round(
                    daily.this_date_uplift_payments),
                'Total reserve payments': lambda daily: self._round(
                    daily.this_date_reserve_payments),
                'Total payments': lambda daily: self._round(
                    daily.this_date_total_payments),
                'Average payments': lambda daily: self._round(
                    daily.this_date_average_payments)
                })

        self.reports['daily_summary'] = ListReporter(daily_columns)
        stats_manager.register_for_daily_stats(
            self.reports['daily_summary'].write_record)

        # set up overall simulation output
        overall_cols = {
            'Total demand': lambda overall: self._round(
                overall.cumulative_demand),
            'Total fixed costs': lambda overall: self._round(
                overall.total_overall_fixed_costs),
            'Total generation costs': lambda overall: self._round(
                overall.total_overall_generation_costs),
            'Total costs': lambda overall: self._round(
                overall.total_overall_costs),
            'Total load shedding': lambda overall: self._round(
                overall.total_overall_load_shedding),
            'Total over generation': lambda overall: self._round(
                overall.total_overall_over_generation),
            'Total reserve shortfall': lambda overall: self._round(
                overall.total_overall_reserve_shortfall),
            'Total renewables curtailment': lambda overall: self._round(
                overall.total_overall_renewables_curtailment),
            'Total on/offs': lambda overall: overall.total_on_offs,
            'Total sum on/off ramps': lambda overall: self._round(
                overall.total_sum_on_off_ramps),
            'Total sum nominal ramps': lambda overall: self._round(
                overall.total_sum_nominal_ramps),
            'Maximum observed demand': lambda overall: self._round(
                overall.max_hourly_demand),
            'Overall renewables penetration rate': lambda overall: self._round(
                overall.overall_renewables_penetration_rate),
            'Cumulative average price': lambda overall: self._round(
                overall.cumulative_average_price)
            }

        if options.compute_market_settlements:
            overall_cols.update({
                'Total energy payments': lambda overall: self._round(
                    overall.total_energy_payments),
                'Total reserve payments': lambda overall: self._round(
                    overall.total_reserve_payments),
                'Total uplift payments': lambda overall: self._round(
                    overall.total_uplift_payments),
                'Total payments': lambda overall: self._round(
                    overall.total_payments),
                'Cumulative average payments': lambda overall: self._round(
                    overall.cumulative_average_payments)
                })

        self.reports['overall'] = ListReporter(overall_cols)
        stats_manager.register_for_overall_stats(
            self.reports['overall'].write_record)

        # set up daily stack graph
        if graphutils_functional and not options.disable_stackgraphs:
            stats_manager.register_for_daily_stats(
                lambda daily_stats: ReportingManager.generate_stack_graph(
                    options, daily_stats) )

            stats_manager.register_for_overall_stats(
                lambda overall_stats: ReportingManager.generate_cost_summary_graph(
                    options, overall_stats))

        super().__init__()

    def save_output(self, out_dir):
        report_dfs = {output_type: pd.DataFrame(reporter.data,
                                                columns=reporter.headers)
                      for output_type, reporter in self.reports.items()}

        with bz2.BZ2File(Path(out_dir, "output.p.gz"), 'w') as f:
            pickle.dump(report_dfs, f, protocol=-1)

    @staticmethod
    def generate_stack_graph(options, daily_stats: DailyStats):

        md_dict = ModelData.empty_model_data_dict()

        system = md_dict['system']

        # put just the HH:MM in the graph
        system['time_keys'] = [
            str(opstats.timestamp.time())[0:5]
            for opstats in daily_stats.operations_stats()
            ]

        system['reserve_requirement'] = _time_series_dict([
            opstats.reserve_requirement
            for opstats in daily_stats.operations_stats()
            ])
        system['reserve_shortfall'] = _time_series_dict([
            opstats.reserve_shortfall
            for opstats in daily_stats.operations_stats()
            ])

        elements = md_dict['elements']

        elements['load'] = {'system_load': {'p_load': _time_series_dict([
            opstats.total_demand
            for opstats in daily_stats.operations_stats()
            ])}}

        elements['bus'] = {'system_load_shed': {
            'p_balance_violation': _time_series_dict([
                opstats.load_shedding
                for opstats in daily_stats.operations_stats()])
            },

            'system_over_generation': {
                'p_balance_violation' : _time_series_dict([
                    -opstats.over_generation
                    for opstats in daily_stats.operations_stats()
                    ])
                }
            }

        ## load in generation, storage
        generator_fuels = {}
        thermal_quickstart = {}
        thermal_dispatch = {}
        thermal_headroom = {}
        thermal_states = {}
        renewables_dispatch = {}
        renewables_curtailment = {}
        storage_input_dispatch = {}
        storage_output_dispatch = {}
        storage_types = {}

        for opstats in daily_stats.operations_stats():
            _collect_time_assert_equal(opstats.generator_fuels, generator_fuels)
            _collect_time_assert_equal(opstats.quick_start_capable, thermal_quickstart)
            _collect_time_assert_equal(opstats.storage_types, storage_types)

            _collect_time(opstats.observed_thermal_dispatch_levels, thermal_dispatch)
            _collect_time(opstats.observed_thermal_headroom_levels, thermal_headroom)
            _collect_time(opstats.observed_thermal_states, thermal_states)

            _collect_time(opstats.observed_renewables_levels, renewables_dispatch)
            _collect_time(opstats.observed_renewables_curtailment, renewables_curtailment)

            _collect_time(opstats.storage_input_dispatch_levels, storage_input_dispatch)
            _collect_time(opstats.storage_output_dispatch_levels, storage_output_dispatch)

        # load generation
        gen_dict = {}
        for g, fuel in generator_fuels.items():
            gen_dict[g] = { 'fuel' : fuel , 'generator_type' : 'renewable' } # will get re-set below for thermal units
        for g, quickstart in thermal_quickstart.items():
            gen_dict[g]['fast_start'] = quickstart
            gen_dict[g]['generator_type'] = 'thermal'

        _add_timeseries_attribute_to_egret_dict(gen_dict, thermal_dispatch, 'pg')
        _add_timeseries_attribute_to_egret_dict(gen_dict, thermal_headroom, 'headroom')
        _add_timeseries_attribute_to_egret_dict(gen_dict, thermal_states, 'commitment')

        _add_timeseries_attribute_to_egret_dict(gen_dict, renewables_dispatch, 'pg')
        _add_timeseries_attribute_to_egret_dict(gen_dict, renewables_curtailment, 'curtailment')
        for g_dict in gen_dict.values():
            if g_dict['generator_type'] == 'renewable':
                pg = g_dict['pg']['values']
                curtailment = g_dict['curtailment']['values']
                g_dict['p_max'] = _time_series_dict([pg_val+c_val for pg_val, c_val in zip(pg, curtailment)])

        elements['generator'] = gen_dict

        # load storage
        storage_dict = {}
        for s, stype in storage_types.items():
            storage_dict[s] = { 'fuel' : stype }
        _add_timeseries_attribute_to_egret_dict(storage_dict, storage_input_dispatch, 'p_charge')
        _add_timeseries_attribute_to_egret_dict(storage_dict, storage_output_dispatch, 'p_discharge')

        elements['storage'] = storage_dict

        figure_path = os.path.join(options.output_directory, "plots","stackgraph_"+str(daily_stats.date)+".png")

        graphutils.generate_stack_graph(ModelData(md_dict),
                                        bar_width=1,
                                        x_tick_frequency=4*(60//options.sced_frequency_minutes),
                                        title=str(daily_stats.date),
                                        save_fig=figure_path)

    @staticmethod
    def generate_cost_summary_graph(options, overall_stats: OverallStats):
        daily_fixed_costs = [daily_stats.this_date_fixed_costs for daily_stats in overall_stats.daily_stats]
        daily_generation_costs = [daily_stats.this_date_variable_costs for daily_stats in overall_stats.daily_stats]
        daily_load_shedding = [daily_stats.this_date_load_shedding for daily_stats in overall_stats.daily_stats]
        daily_over_generation = [daily_stats.this_date_over_generation for daily_stats in overall_stats.daily_stats]
        daily_reserve_shortfall = [daily_stats.this_date_reserve_shortfall for daily_stats in overall_stats.daily_stats]
        daily_renewables_curtailment = [daily_stats.this_date_renewables_curtailment for daily_stats in overall_stats.daily_stats]

        graphutils.generate_cost_summary_graph(daily_fixed_costs, daily_generation_costs,
                                               daily_load_shedding, daily_over_generation,
                                               daily_reserve_shortfall,
                                               daily_renewables_curtailment,
                                               output_directory=os.path.join(options.output_directory, "plots"))
